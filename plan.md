Oma Helen 15‑Minute Energy Integration Specification
====================================================

Overview
--------

This document outlines the design for a Home Assistant integration that fetches electricity usage data in 15-minute intervals (“quarter-hourly” data) from the Oma Helen service. The integration will use the existing oma-helen-cli Python module for authentication and API access, leveraging its function to retrieve quarter-hourly measurements with spot prices[pypi.org](https://pypi.org/project/oma-helen-cli/#:~:text=including 15,exit Exit the CLI application). The integration will create Home Assistant energy sensors to record consumption and optional cost information. It will backfill historical data on first setup and thereafter update daily with the previous day’s data. All sensors and behaviors will conform to Home Assistant’s integration standards and energy data best practices.

Data Source and Authentication
------------------------------

**Oma Helen API via oma-helen-cli:** The integration uses the oma-helen-cli library, which provides a CLI/API client for Helen Oy’s “Oma Helen” service[pypi.org](https://pypi.org/project/oma-helen-cli/#:~:text=Function name What it does,energy consumption for the on)[pypi.org](https://pypi.org/project/oma-helen-cli/#:~:text=including 15,exit Exit the CLI application). This library handles obtaining an API access token and offers high-level methods for data retrieval. In particular, we will call get\_quarterly\_measurements\_with\_spot\_prices\_json, which returns energy consumption measurements for each 15-minute interval between given dates, including corresponding spot price data[pypi.org](https://pypi.org/project/oma-helen-cli/#:~:text=including 15,exit Exit the CLI application). Using this library avoids reinventing authentication logic; the integration will prompt the user for their Oma Helen credentials (username and password) via a Config Flow UI and pass them to oma-helen-cli to log in and fetch data.

**Authentication and Tokens:** On initial setup, the integration will use the provided credentials to obtain an API access token (via get\_api\_access\_token if needed). The token will be stored securely (not in plaintext) in Home Assistant’s config entry storage. The integration will handle token expiration transparently – e.g. oma-helen-cli likely manages refreshing tokens, or the integration will re-login if needed. If the user has multiple delivery sites (multiple electricity contracts or meters with Helen), the integration will allow selecting the appropriate site. The oma-helen-cli can list and select delivery sites (via get\_all\_delivery\_sites and select\_delivery\_site), so the Config Flow can present a dropdown if multiple sites are detected. Each configured entry will correspond to one Helen delivery site (meter). The integration’s manifest will declare the dependency on oma-helen-cli (e.g. require version 1.5.0 or latest) and mark the integration as using a config flow and cloud polling IoT class[GitHub](https://github.com/carohauta/oma-helen-ha-integration/blob/5362eeb816946cd12fba0d7abdcd6ba3d8b27360/custom_components/helen_energy/manifest.json#L7-L16).

Integration Setup and Configuration
-----------------------------------

**Config Flow:** The integration will be installed as a custom component (or eventually a core integration) and set up via Home Assistant’s UI (Settings → Devices & Services → Add Integration). The config flow will gather:

*   **Helen Credentials:** Email/username and password for Oma Helen (these will be used to login and then discarded if possible after obtaining a token).
    
*   **Initial Backfill Days:** The number of past days of data to retrieve on first setup. This will default to a sensible value (e.g. 7 days) and allow a range (perhaps 7–30 days) for the user to choose.
    
*   **Optional Cost Parameters:** If the user wants cost sensors enabled, the config flow will present additional options to input their pricing details. These may include:
    
    *   Fixed contract energy price (in c/kWh) – if the user has a fixed-rate contract or a fixed margin on top of spot prices.
        
    *   Exchange contract margin (in c/kWh) – for spot price contracts, the margin added by Helen (the integration can also attempt to fetch this via get\_exchange\_margin\_price\_json).
        
    *   Transfer cost per kWh (in c/kWh) – the distribution network energy fee (if Helen is the transfer company, this can be fetched via get\_contract\_transfer\_fee; if not, the user can supply their own network provider’s rate).
        
    *   Monthly base transfer fee (in EUR) – the fixed monthly fee for the distribution network, to be prorated daily (if Helen is transfer provider, available via get\_contract\_transfer\_base\_price, otherwise user-supplied).
        
    *   VAT rate – whether prices should include VAT. Spot prices from the API are typically without VAT, so the integration may need to add 10% or 24% VAT (depending on locale) on top of energy and transfer costs if the user desires. This could be a checkbox or selection (for Finland, 24% VAT for electricity).
        

All cost-related fields will be optional; the user can leave them blank to skip cost sensor creation. In many cases, the integration can auto-detect some values (e.g. fetch the contract’s base prices and unit prices via oma-helen-cli), but allowing user input ensures support for scenarios where Helen’s API returns 0 (for example, if Helen is not the distribution company, their API’s transfer fees are 0[GitHub](https://github.com/carohauta/oma-helen-ha-integration/blob/5362eeb816946cd12fba0d7abdcd6ba3d8b27360/README.md#L56-L64), but the user might still want to input their actual transfer fees from another provider).

**Manifest and Standards:** The integration’s manifest.json will list the required Python package (oma-helen-cli), use config\_flow: true, and indicate iot\_class: cloud\_polling since data is fetched from an internet API on a schedule[GitHub](https://github.com/carohauta/oma-helen-ha-integration/blob/5362eeb816946cd12fba0d7abdcd6ba3d8b27360/custom_components/helen_energy/manifest.json#L8-L16). It will follow Home Assistant’s standard integration structure (with \_\_init\_\_.py, config\_flow.py, const.py, and a sensor.py platform for entities). The code will leverage Home Assistant’s asyncio framework and not block the event loop during API calls (calls to oma-helen-cli will be executed in an asynchronous friendly way, possibly using await hass.async\_add\_executor\_job if the library is not async). Proper logging and error handling will be included (e.g., logging in debug the API responses, handling HTTP errors or authentication failures by raising ConfigEntryNotReady or prompting reauthentication if credentials expire).

Data Retrieval and Backfilling
------------------------------

**Historical Backfill on First Setup:** Upon the first time the integration is configured (or when the user re-enables backfill intentionally), it will perform an initial data load of recent historical usage. Using the configured “backfill days” value, the integration will calculate a date range (from today minus N days up to yesterday) to retrieve quarter-hourly data. For example, if backfill days = 7 and today is Dec 14, 2025, it would fetch data from Dec 7, 2025 through Dec 13, 2025 inclusive. The oma-helen-cli function get\_quarterly\_measurements\_with\_spot\_prices\_json allows specifying start and end dates and returns the measurements for each quarter-hour in that range[pypi.org](https://pypi.org/project/oma-helen-cli/#:~:text=including 15,exit Exit the CLI application). The integration will call it once with the full date range if possible, or in batches (e.g. one day at a time) if the API requires shorter spans. The result will be a JSON structure containing timestamps (likely in ISO or epoch format) and values for each 15-minute interval’s consumption (kWh) and spot price (€/MWh or similar units).

After retrieving this data, the integration will import it into Home Assistant’s database with proper timestamps: **each 15-minute interval measurement will be recorded at its corresponding time slot**. This ensures that historical graphs and the Energy Dashboard reflect the usage at the correct times. Because this is historical data (not live sensor readings), we will use Home Assistant’s _external statistics_ feature to insert these past measurements. Using recorder APIs (such as async\_add\_external\_statistics), the integration can add data points for a sensor’s statistics, labeled by time[community.home-assistant.io](https://community.home-assistant.io/t/im-adding-old-data-using-async-add-external-statistics-to-energy-i-cant-figure-out-how-to-show-cost/863868#:~:text=,sensor:daily_consumption). By doing so, we can assign the exact timestamp for each quarter-hour reading (UTC from the API, converted to local time as needed – see **Timezone Alignment** below) instead of trying to retroactively change a sensor’s state history. This approach avoids misusing the sensor state machine for past data; according to Home Assistant guidelines, a sensor with state class “measurement” should represent current measurements, not arbitrary historical points[developers.home-assistant.io](https://developers.home-assistant.io/docs/core/entity/sensor/#:~:text=,Similar to the above). Therefore, leveraging external statistics is the safe way to backfill _yesterday’s_ or last week’s consumption without violating the principle of “present time” sensor states.

Concretely, during backfill the integration will prepare a list of data points for each 15-minute slot (each data point includes: entity\_id (or statistic\_id), timestamp, value, and possibly some metadata like sum or adjustment if required). It will then call Home Assistant’s recorder to insert these points. Once inserted, Home Assistant’s Energy Dashboard and statistics system will treat them as if they had been reported in real-time, and you’ll be able to see past usage in the energy graphs immediately after setup.

**Regular Daily Updates:** After the initial backfill, the integration switches to a daily update mode. It will **fetch only the previous day’s data on a daily schedule**. For example, each day early in the morning, it will retrieve all 96 quarter-hour readings for “yesterday” (00:00 to 23:45 of the previous day). By waiting until the day is over, we ensure that data is complete (the Helen API likely only finalizes full day consumption after the day ends). This daily polling can be scheduled via Home Assistant’s DataUpdateCoordinator or an async\_track\_time\_interval trigger. We will schedule the update for a time when yesterday’s data should definitely be available – e.g. 00:30 or 01:00 local time each night. The coordinator’s update method will identify “yesterday’s date” (likely in local timezone terms), call get\_quarterly\_measurements\_with\_spot\_prices\_json for that single day, and then insert those 96 data points into the statistics database just like the backfill process. Because the integration only ever looks at _past_ data (never the ongoing current day), it avoids partial data updates. Each daily run will ingest a complete set of quarter-hour measurements for the prior day in one batch.

**Missed Data Recovery:** In cases where the integration or Home Assistant was offline or disabled during the scheduled update time, the integration will attempt to recover missing days on the next run. We will store the last date for which data was successfully fetched (e.g. in the ConfigEntry state). On startup or on the next scheduled run, the integration can compare the last fetched date to yesterday and detect any gap. For example, if the service was down for two days, when it comes back it will fetch data for both the missed days before also fetching yesterday’s data. This ensures continuity of the historical record. Similarly, if the Helen API returns incomplete data for a day (say only part of the day’s intervals, perhaps due to a delay in data availability), the integration will log a warning and attempt to refetch that day’s data on the next cycle. We assume Helen’s API normally provides all 96 intervals by midnight, but if not, our design is resilient: it can either retry later that night or include logic to merge new data if some intervals were missing previously. Duplicate insertion of the same interval will be avoided – the integration can check if a given day’s statistics are already present (by querying the recorder or by keeping an internal record of inserted timestamps) to prevent double-counting. If re-fetching yields more complete data (for example, fills in missing intervals), the integration could update those specific intervals’ values via the external statistics call (external stats can overwrite existing points by specifying the same timestamp and statistic ID). The overall goal is to always eventually have a correct and complete set of quarter-hour readings for each day.

Sensor Model and Entities
-------------------------

The integration will define sensor entities to represent the energy usage and costs. These sensors will be registered under a common device (e.g., “Helen Energy Meter” for the specific delivery site) so that in Home Assistant’s UI they appear grouped. Each sensor follows Home Assistant’s entity model (with unique\_id, name, unit, device\_class, etc.) appropriate for its type. The primary sensor types are:

*   **Energy Consumption Sensor** – reports electricity consumption in kWh for each 15-minute interval. (Entity ID example: sensor.helen\_quarterly\_energy or a more specific name based on the contract, e.g., sensor.helen\_energy\_usage).
    
*   **Energy Cost Sensor** (optional) – reports the cost of electricity over each interval or accumulative cost (depending on design, described below). (Example: sensor.helen\_energy\_cost).
    
*   **Energy Price Sensor** (optional) – reports the effective price of electricity (per kWh) for each interval. (Example: sensor.helen\_energy\_price).
    

These sensors are “virtual” in the sense that their state is not continuously polled in real-time, but rather updated with batch data. We have two possible approaches to implement them, and this design will blend the approaches to get the best of both:

1.  **External Statistic Entities:** For the consumption (and cost) data that needs precise timestamp alignment, the integration will utilize external statistics. When we insert the quarter-hour data points into the recorder, Home Assistant will maintain long-term statistics for these values. In the Home Assistant UI, such data can appear in the Energy Dashboard and be queried in the **Statistics** panel. External statistics are identified by an ID with a colon (e.g., sensor:helen\_quarterly\_energy) indicating they are not attached to a continuously updating entity[community.home-assistant.io](https://community.home-assistant.io/t/im-adding-old-data-using-async-add-external-statistics-to-energy-i-cant-figure-out-how-to-show-cost/863868#:~:text=,sensor:daily_consumption). We will register a statistics meta data for the consumption sensor (with unit kWh, device\_class energy, etc.) so that the energy system recognizes it for long-term storage. The cost sensor will similarly have its own statistics series (with unit currency like EUR). Using external stats ensures each quarter-hour reading is recorded at the correct time (as if the sensor had been updating then).
    
2.  **Home Assistant Sensor Entities (State Machine):** In addition to the stats, we may create a conventional sensor entity for user visibility. For instance, we might create sensor.helen\_quarterly\_energy in the entity registry so it’s discoverable. This entity could represent a daily aggregated value or the latest interval’s value. However, since the actual historical values are stored in the stats system, the state of this entity is somewhat secondary. One approach: have the sensor’s state represent the **total consumption for the last day** (or the most recent day fetched). For example, after the integration inserts yesterday’s quarter-hour data, it could set the state of sensor.helen\_quarterly\_energy to the sum of those 96 intervals (i.e., yesterday’s total kWh). This gives the user a quick view of daily usage in one number, while the detailed breakdown is accessible via the energy dashboard or history graphs. Another approach is to not use a normal sensor at all for consumption and solely rely on the statistics (the Energy Dashboard can show the data without there being a continuously updating entity). We will likely implement the daily-total sensor for convenience, but mark it appropriately: it would have device\_class: energy, unit\_of\_measurement: kWh, and state\_class: total\_increasing or measurement depending on semantics. If it represents a daily total that resets every midnight, we could use state\_class: total with a daily last\_reset at midnight, so Home Assistant’s statistics engine can still derive daily differences if needed. Alternatively, if it’s just a static daily total (and not used for further stats), we might mark it as measurement since it’s a sum for a closed period (yesterday). This design decision will be finalized with Home Assistant’s energy integration requirements in mind. The key point is that the integration **will register the sensor in a way that Home Assistant’s Energy features recognize it**. (Home Assistant’s energy management expects either a sensor with accumulating kWh or external stats. We plan to fulfill that expectation with our approach.)
    

**Energy Consumption Sensor Details:** This sensor’s core data is the quarter-hour kWh values. Its attributes may include additional context if needed (for example, we might include an attribute for “Data Source Timestamp” or a boolean “Data Complete” flag for that day). The sensor (if implemented as an entity) will not update every 15 minutes live, but only when new data is ingested (daily). If we set its state to daily total, that state updates once per day. All the granular data is in statistics – which the user can view through the Energy Dashboard’s charts (which can show usage per hour, and since we supply quarter-hour, it will even show finer detail in the stats graphs). Device class will be energy (since it represents energy consumption)[developers.home-assistant.io](https://developers.home-assistant.io/docs/core/entity/sensor/#:~:text=to update. ,consumed by an electric car), and unit is kWh. If an entity is created, state\_class might be total\_increasing (since energy usage accumulates) but we will reset it daily, or it could be measurement of a daily total. We must be careful: Home Assistant specifically says not to use measurement for something like yesterday’s total energy[developers.home-assistant.io](https://developers.home-assistant.io/docs/core/entity/sensor/#:~:text=,Similar to the above) because it’s not a “current” measurement. If we go with a daily total sensor, it’s actually a historical summary, so we might classify it as total with a daily reset instead. Regardless, by using external stats for the 15-min values, we ensure correctness and compliance.

**Energy Cost Sensor:** This sensor will be created if the user opts to track cost. Its purpose is to compute how much money the electricity usage costs, incorporating the spot price and any additional fees. We will calculate cost per interval as follows: For each 15-min interval, cost = consumption\_kWh \* energy\_price\_per\_kWh. The energy\_price\_per\_kWh in turn is derived from the Helen spot price plus any fixed contract additions (e.g., for an exchange electricity contract, energy\_price = spot\_price + margin, and then plus VAT). If a fixed-price contract, energy\_price is simply the fixed unit rate (plus VAT if needed). The integration will also incorporate transfer fees: essentially, total price per kWh = energy price + transfer price (both include VAT if applicable). The monthly base transfer fee will be handled by distributing it across intervals or days. Our assumption is to **prorate the monthly base fee to a daily amount**: daily\_base\_fee = (monthly\_fee / number\_of\_days\_in\_month). We will add that daily base cost to the cost calculation. To distribute it across the day’s intervals, we can either: (a) evenly distribute across all 96 intervals (so each interval gets an extra base\_fee\_daily/96 cost added), or (b) add it as a one-time addition to the daily total. Distributing it evenly keeps each quarter-hour cost correctly slightly higher, and ensures the sum of intervals for the day equals the daily fixed cost + variable cost. We will implement the even distribution for accuracy on an interval basis.

The Energy Cost sensor can be represented similarly to the consumption sensor. We will use an **external statistic for cost** with unit “EUR” (or the user’s currency) and device class monetary. This allows Home Assistant’s Energy dashboard to display costs alongside consumption. In fact, Home Assistant requires pairing a consumption statistic with a corresponding cost statistic for tracking expenses[community.home-assistant.io](https://community.home-assistant.io/t/im-adding-old-data-using-async-add-external-statistics-to-energy-i-cant-figure-out-how-to-show-cost/863868#:~:text=If you’re using an external,fixed price is not available) – since we are using external stats (sensor with colon), the UI will not allow a built-in fixed price, so we must supply the cost data ourselves[community.home-assistant.io](https://community.home-assistant.io/t/im-adding-old-data-using-async-add-external-statistics-to-energy-i-cant-figure-out-how-to-show-cost/863868#:~:text=,sensor:daily_consumption)[community.home-assistant.io](https://community.home-assistant.io/t/im-adding-old-data-using-async-add-external-statistics-to-energy-i-cant-figure-out-how-to-show-cost/863868#:~:text=If you’re using an external,fixed price is not available). Our integration will create a statistic ID for cost (perhaps sensor:helen\_energy\_cost) and insert hourly or quarter-hourly cost data. Each interval’s cost is computed as described; when we insert into statistics, Home Assistant will aggregate it to hourly/daily totals in the Energy dashboard automatically. For user-friendliness, we might also create an entity sensor.helen\_energy\_cost in the state machine which could hold the **current month’s total cost** or **yesterday’s total cost**. However, this might be redundant if the Energy UI covers it. In the reference Helen integration by a community developer, the primary sensor’s state was the total cost of the ongoing month, with attributes for consumption etc[GitHub](https://github.com/carohauta/oma-helen-ha-integration/blob/5362eeb816946cd12fba0d7abdcd6ba3d8b27360/README.md#L52-L60). In our case, we could set sensor.helen\_energy\_cost state to the current day’s total cost (updating daily), or current month’s total cost if we accumulate over time. For simplicity, we may start with daily granularity – after fetching yesterday’s data, set the cost sensor’s state to yesterday’s total cost (and possibly an attribute to show that it’s yesterday’s value). This gives immediate feedback on daily spending.

**Energy Price Sensor:** The price sensor is optional and mainly useful for real-time insight into electricity rates. Since our integration fetches data once per day (by design), a _current_ price is not directly available (we only know yesterday’s prices after the fact). However, to support use cases like exchange (spot) electricity, we can still provide a sensor for _today’s spot price or yesterday’s average price_. We envision supporting “per-hour pricing” in the future, meaning the integration could retrieve day-ahead spot prices (Helen’s API likely has a method for “spot\_prices\_chart\_data”[pypi.org](https://pypi.org/project/oma-helen-cli/#:~:text=get_contract_type Get the contract type,each quarter between given dates)) to populate a price schedule for the current day. This would allow a sensor that updates hourly or 15-min with the going price. As a placeholder, we will implement sensor.helen\_energy\_price to show the _last known price_ from the data fetch – effectively the spot price (plus margin and VAT) of the most recent quarter fetched (which would be yesterday’s 23:45 interval). That isn’t very useful alone, so we will enhance this in future by adding a separate job to fetch today’s spot prices each day (these are published in advance for the whole day). With that, sensor.helen\_energy\_price could always show either the current quarter’s price (if we know it) or the next quarter’s price. For now, the specification includes this sensor as a stub for extensibility. It will have unit\_of\_measurement “€/kWh” (assuming Euro; currency could be dynamic if needed) and likely device\_class: monetary (though Home Assistant does not have a special class for price per unit, we can treat it as monetary value). Its state\_class would be measurement since it’s an instantaneous price. This sensor will _not_ use external statistics; it will be a normal sensor that updates whenever new price info is available (which might be only daily, or hourly if extended with day-ahead data).

All entities will have human-friendly names and icons. For example, sensor.helen\_quarterly\_energy might be named “Helen Energy Consumption (15m)” and use the lightning bolt energy icon. Cost sensor can use a currency icon, and price sensor likewise. Each sensor will be tied to the device representing the contract (with attributes identifying the contract or meter ID, so if the user has multiple Helen integrations they can distinguish them). The device info will include the integration name, possibly the service provider (Helen), and a link to the Helen account if feasible.

Home Assistant Integration Standards
------------------------------------

This integration is designed in line with the official Home Assistant developer guidelines[developers.home-assistant.io](https://developers.home-assistant.io/docs/core/entity/sensor/#:~:text=Available state classes). Key practices include:

*   **Config Flow UI**: Configuration is done through the UI flow as described, rather than YAML, for ease of use and compliance with modern standards. Sensible validation and error messages will be provided (e.g., if login fails or if an input is out of range).
    
*   **Polling Mechanism**: The integration uses scheduled polling (daily) to retrieve data. Since this is cloud data, it’s marked as cloud\_polling in the manifest[GitHub](https://github.com/carohauta/oma-helen-ha-integration/blob/5362eeb816946cd12fba0d7abdcd6ba3d8b27360/custom_components/helen_energy/manifest.json#L8-L16). We ensure that network calls are done asynchronously or in the background to not block Home Assistant’s main thread. The DataUpdateCoordinator pattern will be used to manage the polling interval and to handle the data refresh logic in one place. Even though the update is daily, using a coordinator provides a clean way to trigger updates and share data to multiple entities if needed.
    
*   **Entity Model**: Sensor entities will subclass SensorEntity and implement properties like native\_value, native\_unit\_of\_measurement, device\_class, and state\_class appropriately. We will use entity\_registry\_enabled\_default = True for the main sensors so they show up by default. The integration will also implement unique\_id for each entity (constructed from a stable identifier like the Helen contract ID plus sensor type) so that entities are globally unique and can survive name changes.
    
*   **Data Storage**: We will avoid storing large amounts of raw data in memory long-term. When the quarter-hour data is fetched, it will be processed and inserted into Home Assistant’s statistics (recorder) and then can be discarded from memory. If needed (for example, to compute daily totals or to check if data is missing), we might sum up or iterate through it, but we will not keep weeks of raw data in the integration’s memory. Home Assistant’s database will be the source of truth for historical values.
    
*   **Error Handling and Logging**: The integration will log errors if the data fetch fails (e.g., network issues, API returns 500, etc.) and will retry on the next schedule. If authentication fails (perhaps the user changed their Helen password), we will set the config entry to require reauthentication (Home Assistant supports an appropriate flow for that). In case of unexpected data (e.g., missing intervals), we will warn the user via logs and possibly a persistent notification if the data gap persists.
    
*   **Performance Considerations**: Fetching 96 intervals per day is not heavy, and doing it once a day is very light load for both Home Assistant and the Helen API. Even backfilling 30 days (which is 2880 data points) is manageable. We will ensure the JSON parsing and database writes are done efficiently (possibly chunking if needed). The external statistics insertion might need to insert many rows; we will batch them in as few calls as possible.
    
*   **Security**: User credentials are stored encrypted by Home Assistant, and the integration will not expose them. All communication with Helen API is over HTTPS (assumed via oma-helen-cli). No sensitive data beyond consumption and cost is stored.
    

We will also write unit tests for key functions (e.g., parsing the API response, cost calculation logic) to ensure correctness. The integration could be submitted to the Home Assistant Community Store (HACS) initially, and if mature, potentially as an official integration following their contribution guidelines.

Timezone Alignment of Data
--------------------------

One important design aspect is aligning the 15-minute interval data with Home Assistant’s timezone and the user’s expectation of a “day”. Helen’s API likely returns timestamps in UTC (or it returns data indexed by local time but with an implicit timezone). We assume for this design that the measurements are timestamped in UTC. Home Assistant’s internal recorder also uses UTC for storing timestamps. However, the user typically views their energy usage per day in _local time_. In Finland (the user’s location), the timezone is EET/EEST (UTC+2 in winter, UTC+3 in summer). This means that if the API gives us data from 00:00 UTC to 23:45 UTC, that actually spans 2:00am to 1:45am local time the next day during winter. We need to ensure that when we say “yesterday’s data” we really mean the local date’s yesterday (midnight to midnight local).

**Querying the API by Local Day:** The integration will determine the date range to fetch in terms of local dates, and convert those to UTC for the API call if needed. For example, to fetch data for December 13, 2025 (yesterday local date), and if the timezone is UTC+2, the integration will request data from 2025-12-12 22:00 UTC up to 2025-12-13 21:59 UTC (which corresponds to 00:00 to 23:59 on Dec 13 local). We will rely on Python’s timezone conversions (using datetime with the local timezone info) to get the correct UTC range. It’s possible that the Oma Helen API might also accept a date without time and return that local day’s data; if that’s the case, we’ll use that functionality. Otherwise, manual conversion is done.

**Storing with Correct Timestamps:** When inserting the quarter-hour data points, we will attach a timezone-aware timestamp (likely converted to UTC before storing, as the recorder expects UTC). The Home Assistant UI will automatically translate times to the user’s local timezone when displaying history graphs. This means that if we inserted a point at “2025-12-13T21:00:00+00:00” (which is 23:00 local on Dec 13 if UTC+2), the history graph for Dec 13 (local) will show a point at 23:00, as expected. Essentially, by fetching according to local day and storing in UTC, we align the data so that each local day’s consumption stays within that day.

**Daylight Savings Time Handling:** We must consider DST transitions:

*   In spring (DST start), the local clock skips an hour (e.g., jumps from 02:00 to 03:00, meaning one hour of local time is missing). On that date, a local “day” has only 23 hours (92 intervals). If we query by local day, we might get 92 intervals of data. The integration should handle that – it will insert whatever intervals exist. Home Assistant’s energy calculations will naturally see a smaller total for that day (which is correct, as it was one hour shorter). We will not artificially create 4 missing intervals; they simply won’t exist since the clock skipped. If the API still returns 96 intervals by using UTC times (e.g., covering a 24h UTC span which actually spills into the next local day by an hour), we will _not_ use that, because that would attribute some consumption to a different local day. Instead, we strictly focus on the local day window. In practice, that means on the spring DST day, the API query might be something like 00:00 local = 22:00 UTC previous day, to 23:59 local = 20:59 UTC (next day), which is 23 hours of data. We’ll retrieve that.
    
*   In autumn (DST end), the local clock repeats an hour (02:00–02:59 happens twice), so a local day has 25 hours (100 intervals). We need to capture all 100 intervals. In UTC, this corresponds to a 25-hour span (because the UTC offset shifts). As long as we query from 00:00 local (which is 21:00 or 22:00 UTC of previous day depending on DST) to 23:59 local (which would be 20:59 or 21:59 UTC next day), we’d be covering 25 hours of UTC time. The API might or might not handle that well – if it expects a start and end in UTC, we just give the extended range. If it expects local date, hopefully it returns 100 entries. We will verify this scenario with the API. Our design assumes it’s possible to get the extra hour data; the integration will insert all received intervals. This means one “day” in the stats might have 100 points. Home Assistant’s energy dashboard can handle that (it sums whatever points exist between the day’s boundaries).
    

We will add a note in documentation for the user about DST: on the spring transition day, the daily total will cover 23 hours, and on the autumn transition, 25 hours, which is expected behavior due to the shift.

**Timezone Setting:** We will use Home Assistant’s configured timezone (accessible via hass.config.time\_zone) for all conversions, ensuring the integration automatically adapts to the user’s locale. If the user is in a different timezone than Finland, the local day definition will still apply – e.g., someone running Home Assistant in UTC- for Finnish data might align differently, but since likely only Helen customers in Finland use it, this is a minor concern.

Handling Partial and Error Conditions
-------------------------------------

Despite our careful scheduling, there are scenarios where data might be missing or need special handling:

*   **API Downtime or Data Lag:** If the Helen API is down or slow to update, the integration might not get any data for yesterday when expected. The integration will handle an empty or error response by logging it and will **not** mark the data as fetched. This ensures it will try again on the next cycle (or the user can manually trigger an update via a service or Reload). The config entry could remain in a “temporary error” state (without unloading sensors) if this happens for multiple days, so that when data becomes available we backfill it.
    
*   **Incomplete Data:** If the API returns a partial day (e.g., only 80 out of 96 intervals), the integration might choose to insert what’s available and mark it incomplete. However, inserting partial data could confuse totals. A better strategy is to wait and retry a few hours later, assuming the missing intervals might appear (some utilities have delays in providing final readings). We can implement a secondary schedule on the same day: e.g., if at 00:30 we got only part of the data, schedule another attempt at 03:00. By then, data might be complete. If by the next day’s run it’s still incomplete, we’ll insert what we have (to avoid indefinite stalling) and log a warning indicating which intervals are missing (perhaps fill them as 0 or null). The Energy Dashboard would treat missing intervals effectively as zero consumption, which might slightly under-report usage. The user should be alerted to check their official data if such a gap occurs.
    
*   **Home Assistant Restart Mid-Run:** If HA restarts while we are performing a data update, our coordinator will restart as well. We will design the update method to be idempotent and handle partial progress. For example, if it had fetched the data but crashed before inserting, on restart it might fetch again or detect the data is not applied and reapply it. Duplicate inserts should be prevented as discussed (check for existing stats).
    
*   **Data Corrections:** In rare cases, the energy provider might correct past data (e.g., if a meter reading was updated). If the Oma Helen API reflects such corrections, our integration won’t automatically know. However, we could provide a Home Assistant service (e.g., helen\_energy.refresh\_statistics) that a user can call for a given date range which will re-fetch and overwrite the stored data for those dates. This gives a path to correct any discrepancies.
    

Extensibility and Future Features
---------------------------------

This integration is designed with future extensions in mind:

*   **Additional Sensor Types:** The architecture (using a DataUpdateCoordinator and separate sensor entities) allows adding more sensor platforms easily. For example, if Helen’s API provides outdoor temperature or humidity (perhaps some contracts have a device that measures these, or they provide weather data with consumption), we could add sensors for those. They would simply involve an additional API call and new SensorEntity classes. Since we already handle authentication and site selection, any endpoint from Oma Helen can be integrated. These sensors would typically be real-time or daily values and would follow similar patterns for polling. Another example might be a sensor for **monthly energy consumption** or **monthly cost**, if the user wants a running total – this could be computed from the daily data we have or fetched via get\_monthly\_measurements\_json from the API. Because our integration stores granular data, computing monthly totals is straightforward and could be exposed as separate sensors or as attributes.
    
*   **Hourly Data Mode:** While the default and focus is 15-minute granularity (since Helen and Nord Pool operate on quarter-hour intervals nowadays), some users might prefer or only need hourly data. The oma-helen-cli has get\_hourly\_measurements\_with\_spot\_prices\_json[pypi.org](https://pypi.org/project/oma-helen-cli/#:~:text=get_spot_prices_chart_data Get spot prices from,each quarter between given dates) which returns per-hour data between dates. In future, we could add an option to fetch hourly instead of quarter-hourly. This could reduce data volume by a factor of 4 and might suffice for those not needing fine detail. The integration can be structured to support both: e.g., an internal setting or separate sensor for hourly vs quarter-hourly. Perhaps we create a different sensor (sensor.helen\_hourly\_energy) if that mode is chosen. Because the core logic (authentication, scheduling) is similar, we would just call a different API function and adjust the expected number of intervals per day (24 instead of 96). This extension would also help if Helen ever deprecates quarter-hour data or if a user’s contract only provides hourly data.
    
*   **Real-time Spot Price and Forecast:** As mentioned, we plan to integrate day-ahead pricing. The Nord Pool exchange publishes next day’s prices for Finland on the previous day afternoon. If Helen’s API (or another source) can provide these 15-min prices (the CLI’s get\_spot\_prices\_chart\_data suggests it can get a single day’s prices[pypi.org](https://pypi.org/project/oma-helen-cli/#:~:text=get_contract_type Get the contract type,each quarter between given dates)), the integration could fetch today’s prices at midnight or at regular intervals and update a _forecast_ sensor or the price sensor accordingly. This would enable the user to see the current price and upcoming prices directly in Home Assistant. It doesn’t affect energy consumption directly, but it’s useful for automations (e.g., run heavy appliances when price is low). We aim to design the integration such that adding a periodic update for price (separate from the consumption update) is possible. Perhaps a second coordinator or a time trigger can update sensor.helen\_energy\_price every hour with the current quarter’s price during the day.
    
*   **Multiple Accounts or Multi-Instance:** The integration should support multiple config entries (if the user has multiple Helen accounts or meters). Our use of unique IDs and device info will accommodate that (each entry will use the delivery site or account ID to namespace its entities). Home Assistant will show them as separate devices (e.g., “Helen Energy Meter (Home)” and “Helen Energy Meter (Cabin)”). The design ensures that scheduling is done per entry – so each account fetches its own data daily. There is minimal risk of conflict since each coordinator handles a distinct set of statistic IDs.
    
*   **Home Assistant Energy Dashboard Integration:** We will ensure our sensors and statistics are properly registered so that the user can add them to the Energy Dashboard in Home Assistant. Specifically, the user will be able to go to **Settings → Energy** and add a consumption source by picking our consumption statistic (it will appear as an option like “Helen Quarterly Energy”). For cost tracking, because we use external stats, the Energy settings will require selecting our cost statistic as the associated cost (since fixed price option is disabled for external stats)[community.home-assistant.io](https://community.home-assistant.io/t/im-adding-old-data-using-async-add-external-statistics-to-energy-i-cant-figure-out-how-to-show-cost/863868#:~:text=If you’re using an external,fixed price is not available). We will document this step for the user. In the future, if Home Assistant allows, we might register the entities in a way that they appear as normal drop-down options (this is largely automatic if device\_class and state\_class are set correctly on the stats metadata). Additionally, if any adjustments are needed (like converting units or applying calibration), we will incorporate that so that energy calculations (kWh to MWh or to cost) remain accurate.
    

In summary, the integration is built to be robust and extensible, focusing first on the core need: importing quarter-hour consumption and cost data for tracking in Home Assistant. By following best practices (like not abusing sensor state for backfill data and using the statistics system properly), we ensure data integrity and alignment with Home Assistant’s philosophy. Users will gain insight into their energy usage with 15-minute resolution, which is valuable for spotting patterns and responding to price fluctuations. All of this is accomplished while adhering to Home Assistant’s standards and leaving room for future enhancements such as additional sensor types and real-time data features.